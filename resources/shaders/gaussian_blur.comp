#version 430

layout(local_size_x = 32, local_size_y = 32) in;

const int pad = 5;
const int kernel_size = 11;
const float PI = 3.14159265359;
shared float weights[11];
shared vec4 sharedMemory[32 + 2 * pad][32 + 2 * pad];
layout(rgba32f, binding = 0) uniform readonly image2D image;
layout(rgba32f, binding = 1) uniform writeonly image2D blurredImage;


void main() 
{
    ivec2 globalId = ivec2(gl_GlobalInvocationID.xy);
    ivec2 localId = ivec2(gl_LocalInvocationID.xy);
    if (localId.x < 11) {
        weights[localId.x] = exp(-pow((localId.x - pad) / pad, 2) / 2) / sqrt(2 * PI) / pad;
    }
    // We need to fill only edge and central pixels for each worker
    // It's easy to check that all pixels will be filled
    if (localId.x < pad) {
        if (localId.y < pad) {
            sharedMemory[localId.y][localId.x] =
             globalId.x >= pad && globalId.y >= pad ? imageLoad(image, ivec2(globalId.x - pad, globalId.y - pad)) : vec4(0.0);
        }
        if (localId.y >= 32 - pad) {
            sharedMemory[localId.y + 2 * pad][localId.x] =
             globalId.x >= pad && globalId.y < imageSize(image).y - pad ? imageLoad(image, ivec2(globalId.x - pad, globalId.y + pad)) : vec4(0.0);
        }
        sharedMemory[localId.y + pad][localId.x] =
         globalId.x >= pad ? imageLoad(image, ivec2(globalId.x - pad, globalId.y)) : vec4(0.0);
    }
    if (localId.x >= 32 - pad) {
        if (localId.y < pad) {
            sharedMemory[localId.y][localId.x + 2 * pad] =
             globalId.x < imageSize(image).x - pad && globalId.y >= pad ? imageLoad(image, ivec2(globalId.x + pad, globalId.y - pad)) : vec4(0.0);
        }
        if (localId.y >= 32 - pad) {
            sharedMemory[localId.y + 2 * pad][localId.x + 2 * pad] =
             globalId.x < imageSize(image).x - pad && globalId.y < imageSize(image).y - pad ? 
             imageLoad(image, ivec2(globalId.x + pad, globalId.y + pad)) :
             vec4(0.0);
        }
        sharedMemory[localId.y + pad][localId.x + 2 * pad] =
         globalId.x < imageSize(image).x - pad ? imageLoad(image, ivec2(globalId.x + pad, globalId.y)) : vec4(0.0);
    }
    if (localId.y < pad) {
        sharedMemory[localId.y][localId.x + pad] =
         globalId.y >= pad ? imageLoad(image, ivec2(globalId.x, globalId.y - pad)) : vec4(0.0);
    }
    if (localId.y >= 32 - pad) {
        sharedMemory[localId.y + 2 * pad][localId.x + pad] =
         globalId.y < imageSize(image).y - pad ? imageLoad(image, ivec2(globalId.x, globalId.y + pad)) : vec4(0.0);
    }
    sharedMemory[localId.y + pad][localId.x + pad] = imageLoad(image, ivec2(globalId.x, globalId.y));
    barrier();

    vec4 leftPadBlur = vec4(0.0);
    vec4 rightPadBlur = vec4(0.0);
    vec4 mainBlur = vec4(0.0);
    for (int i = 0; i < kernel_size; ++i) {
        if (localId.x < pad) {
            leftPadBlur += sharedMemory[localId.y + i][localId.x] * weights[i];
        }
        if (localId.x >= 32 - pad) {
            rightPadBlur += sharedMemory[localId.y + i][localId.x + 2 * pad] * weights[i];
        }
        mainBlur += sharedMemory[localId.y + i][localId.x + pad] * weights[i];
    }

    barrier();

    if (localId.x < pad) {
        sharedMemory[localId.y + pad][localId.x] = leftPadBlur;
    }
    if (localId.x >= 32 - pad) {
        sharedMemory[localId.y + pad][localId.x + 2 * pad] = rightPadBlur;
    }
    sharedMemory[localId.y + pad][localId.x + pad] = mainBlur;

    barrier();

    mainBlur = vec4(0.0);

    for (int i = 0; i < kernel_size; ++i) {
        mainBlur += sharedMemory[localId.y + pad][localId.x + i] * weights[i];
    }
    imageStore(blurredImage, globalId, mainBlur);
}